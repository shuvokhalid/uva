/**
   uva online judge
   problem name :: Heavy Cycle Edges;
   problem id   :: 11747;
   catagory     :: graph , minimum spanning tree;
   my solution .............
**/

#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <string.h>
#include <math.h>
#include <conio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <list>
#include <sstream>
#include <ctime>
#include <limits.h>
#include <utility>
#include <bitset>
#include <cctype>
#include <deque>
#include <fstream>

using namespace std;

const int NN = 25000 + 4;

struct point {
	int x , y , w;
	bool operator < (const point &pp) const {
		return w < pp.w;
	}
};

vector < point > vp;
vector < int > hw;
int parr[NN];

int find__ (int u) {
	if (u != parr[u])
	    parr[u] = find__ (parr[u]);
	return parr[u];
}

void get_high_weight (int nn) {
	for (int i = 0; i <= nn; i++)
	    parr[i] = i;
	sort (vp.begin() , vp.end());
	int cnt = 0;
	for (int i = 0; i < vp.size(); i++) {
		int u = find__ (vp[i].x);
		int v = find__ (vp[i].y);
		if (u != v)
			parr[u] = v;
		else hw.push_back(vp[i].w);
	}
}

int main () {
	int n , m;
	while (scanf ("%d%d" , &n , &m) == 2) {
		if (!n && !m) break;
		for (int i = 0; i < m; i++) {
			point edge;
			scanf ("%d%d%d" , &edge.x , &edge.y , &edge.w);
			vp.push_back(edge);
		}
		get_high_weight (n);
		int sz = hw.size();
		if (sz == 0) puts ("forest");
		else if (sz == 1) printf ("%d\n" , hw[0]);
		else {
			for (int i = 0; i < sz - 1; i++)
			    printf ("%d " , hw[i]);
			printf ("%d\n" , hw[sz - 1]);
		}
		hw.clear();
		vp.clear();
	}
}
